; Text rendering and tools
;
;


.varloc("tempdata")
textImageBuffer   .var(8)
.varvalidate(TEMPDATA_SIZE)


;HL = string address
printF:
	ex de,hl	;puts string into DE
printF_loop:
	ex de,hl	;At start of loop, put string into HL
	ld bc,printF_loop
	push bc		;Loop construct stored on stack. Allows ret to jp back here.
	ld	a,(hl)	;retrieve value from there
	ex  de,hl   ;And store string in DE. We need HL to do calculations.
	inc de
	cp  $20
	jr	c,+_
	push de
		call printChar
	pop de
	ret
_:	ld  b,a
	inc b
	djnz printF_skipeof
	;0 - EOF
	pop af		;remove jumpback and expose true return address
	ret
printF_skipeof:
	djnz printF_skipsetxy
	;1 - setxy
	ld	hl,textx
	ld	a,(de)
    inc de
	inc a
	jr	z,+_
	dec a
	ld  (hl),a
_:	inc hl
	ld  a,(de)
    inc de
	inc a
	jr  z,+_
	dec a
	ld  (hl),a
_:	ret	;19
printF_skipsetxy:
	djnz printF_skipaddxy
	;2 - addxy
	ld  hl,textx
	ld  b,2
_:	ld  a,(de)
	add a,(hl)
	ld	(hl),a
	inc hl
	inc de
	djnz -_
	ret
printF_skipaddxy:
	djnz printF_skipcall
	;3 - call (z80 subroutine)
	call deindtobc
	push de
		ld  de,+_
		push de
			push bc
			ret
_:	pop de
	ret
printF_skipcall:
	djnz printF_skipprint
	;4 - print formatted text at address
	call deindtohl
	push de
		call printF
	pop de
	ret
printF_skipprint:
	djnz printF_skipprintacc
	;5 - print acc using supplied num flags
	ld  a,(de)
	inc de
	push de
		ld  hl,(textacc)
		call dispHL
	pop de
	ret
printF_skipprintacc:
	djnz printF_skipjrfnz
	;6 - move printf head to relative address if flag is set (not zero)
	call printF_jrfsub
	ret z
	ex  de,hl
	ret
printF_skipjrfnz:
	djnz printF_skipjrfz
	;7 - move printf head to relative address if flag is reset (zero)
	call printF_jrfsub
	ret nz
	ex  de,hl
	ret
printF_skipjrfz:
	djnz printF_skipdrawbox
	;8 - draws a box at the specified location
	;I don't want to do this right now. Can we do this later? Please?
	inc de
	inc de
	inc de
	inc de
	ret
printF_skipdrawbox:
	djnz printF_skipmenuopt
	;9 - record menu option at current cursor location
	ld	hl,menuoptions
	ld	a,(hl)
	add a,2
	and menuoptionmask		;prevent overrun
	ld	(hl),a
	ld	bc,(textx)
	ld	(hl),c
	inc hl
	ld	(hl),b
	ret
printF_skipmenuopt:
	djnz printF_skipnewline
	;10 - newline
	ld	hl,texty
	ld	a,(hl)
	add a,NEWLINE_HEIGHT
	ld	(hl),a
	inc hl
	ld	a,(hl)	;textxstart
	dec hl
	dec hl
	ld	(hl),a
	ret
printF_skipnewline:
	djnz printF_skipsetflag
	;11 - sets a game flag
	ld 	a,(de)
	inc de
	call getgameflag
	or  (hl)
	ld  (hl),a
	ret
printF_skipsetflag:
	djnz printF_skiptogflag
	;12 - toggles a game flag
	ld 	a,(de)
	inc de
	call getgameflag
	xor (hl)
	ld  (hl),a
	ret
printF_skiptogflag:
	djnz printF_skipsetleftmargin
	;13 - reused CR for: set current cursor position to be the left margin
	ld	hl,textx
	ld	a,(hl)
	inc hl
	inc hl
	ld	(hl),a
	ret
printF_skipsetleftmargin:
	djnz printF_skipclearacc
	;14 - clear text accumulator
	ld  hl,0
	ld	(textacc),hl
	ret
printF_skipclearacc:
	djnz printF_skipexacc
	;15 - exchange text accumulator with shadow text accumulator
	push de
		ld	de,(textacc)
		ld	hl,(textaccshadow)
		ex  de,hl
		ld	(textacc),de
		ld	(textaccshadow),hl
	pop de
	ret
printF_skipexacc:
	djnz printF_skipsetacc1
	;16 - set text accumulator with 1 byte value, leaving 2nd byte untouched.
	ld	a,(de)
	inc de
	ld	(textacc),a
	ret
printF_skipsetacc1:
	djnz printF_skipsetacc2
	;17 - set text accumulator with a 2 byte value
	ld	a,(de)
	ld  L,a
	inc de
	ld  a,(de)
	ld  H,a
	inc de
	ld  (textacc),hl
	ret
printF_skipsetacc2:
	djnz printF_skipadrtoacc1
	;18 - set text accumulator to a 1 byte value at given address. 2nd byte unaffected.
	call deindtohl
	ld  a,(hl)
	ld	(textacc),a
	ret
printF_skipadrtoacc1:
	djnz printF_skipadrtoacc2
	;19 - set text accumulator to a 2 byte value at given address.
	call deindtohl
	ld  a,(hl)
	inc hl
	ld	h,(hl)
	ld  L,a
	ld	(textacc),hl
	ret
printF_skipadrtoacc2:
	djnz printF_skipsetidx
	;20 - set text index to a 2 byte value. This value is intended to be an address.
	call deindtohl
	ld	(textidx),hl
	ret
printF_skipsetidx:
	djnz printF_skipsetindexed
	;21 - add address in text index with offset and add the unsigned byte found
	;     at that address with the 2 byte value in the text accumulator.
	ld	hl,(textidx)
	ld	a,(de)
	call addAtoHL
	ld	a,(hl)
	ld	hl,(textacc)
	call addAtoHL
	ld	(textacc),hl
	ret
printF_skipsetindexed:
	djnz printF_skipmltacc1
	;22 - Multiply the value with the text accumulator, storing only the
	;     first byte of the result
	call printF_multaccsub
	ld	a,L
	ld	(textacc),a
	ret
printF_skipmltacc1:
	djnz printF_skipmltacc2
	;23 - Multiply the value with the text accumulator, storing only the high
	;     byte of the result into the first text accumulator byte.
	;     This variation exists to perform division via reciprocal multiplication
	call printF_multaccsub
	ld	a,H
	ld	(textacc),a
	ret
printF_skipmltacc2:
;	djnz printF_skip
;	ret
;printF_skip:
;	djnz printF_skip
;	ret
;printF_skip:
	ret



printF_multaccsub:
	ld  a,(de)
	push de
		ld 	e,a
		ld	a,(textacc)
		ld	h,a
		call multEandH
	pop de
	ret

printF_jrfsub:
	ld  a,(de)
	inc de
	call getgameflag
	and (hl)
	push af
		ld  a,(de)
		inc de
		ld  L,a
		add a,a	;sign bit into carry
		sbc a,a	;0 if no carry, $FF if carry
		ld  h,a	;doing this to sign-extend HL since rel was a signed number
		add hl,de
	pop af
	ret

;in: A=flagid
;out: HL=flagadr, A=mask(flag set, AND to isolate)
;destroys: B
getgameflag:
	ld	b,a
	rrca
	rrca
	rrca
	and $1F
	ld  hl,gameflags
	call addAtoHL
	ld  a,b
	and 7
	ld  b,a
	ld  a,1
	ret z
_:	add a,a
	djnz -_
	ret

deindtobc:
	ld  a,(de)
	inc de
	ld  c,a
	ld  a,(de)
	inc de
	ld  b,a
	ret

deindtohl:
	ex  de,hl
	ld	e,(hl)
	inc hl
	ld  d,(hl)
	inc hl
	ex  de,hl
	ret

;==============================================================================
printChar:
	ld  de,textImageBuffer
    ld  L,a
    ld  h,0
    ld  c,L
    ld  b,h
    add hl,hl
    add hl,bc   ;multiply by 3 to arrive at fixed-width font offset.
    ld  bc,fontData
    add hl,bc
    ld  c,(hl)  ;Retrieve first byte of font data.
    ld  a,$F0 
    and c
    cp  $F0
	jr	z,printChar_wide
	;Size is in high nibble of C (and A). First byte of stream in low nibble.
	;Size for thin character cannot be higher than 4, so testing bit 7 for
	;vertical shift is safe. Size still needs to be preserved.
	add a,a
	jr	nc,printChar_thinVertSkip
	xor a
	ld	(de),a
	inc de
	res 7,c
printChar_thinVertSkip:
	ld	a,c
	rlca
	rlca
	rlca
	rlca
	ld  c,a
	and $F0
	ld	(de),a
	inc de
	;Preserving size before it is destroyed
	ld	a,c
	and $0F
	push af		;**
		ld  b,2
printChar_thinLoop:
		inc hl
		ld	c,(hl)
		ld  a,$F0
		and c
		ld	(de),a
		inc de
		ld  a,c
		rlca
		rlca
		rlca
		rlca
		and $F0
		ld  (de),a
		inc de
		djnz printChar_thinLoop
		jr  printChar_render
printChar_wide:
	;Size is in low nibble of C. It is technically possible for a wide char to
	;be 8 wide, but bit 3 is repurposed for vertical split. None of the
	;original characters are that wide, but just in case, treat a width of
	;zero (0) after AND 7 as a width of 8 since wide characters cannot
	;be zero-width (if they were, they'd be thin characters, not wide. A
	;deviation from this is considered a formatting error.)
	bit 3,c
	jr	nz,printChar_wideVertSkip
	res 3,c
	xor a
	ld  (de),a
	inc de
printChar_wideVertSkip:
	ld  a,c
	and 7
	jr	nz,printChar_wideDoNotFixWidth
	ld	a,8
printChar_wideDoNotFixWidth:
	push af		;**
		inc hl
		ld  a,(hl)
		inc hl
		ld  h,(hl)
		ld  L,a
		ld  bc,5
		ldir
printChar_render:
		xor a
		ld	(de),a
.assert(texty == (textx+1), "Var texty must be immediately after textx")
		ld	hl,(textx)
	pop af		;**
	add a,L
	ld  (textx),a
	ld  a,L
	ld  L,h
	ld  b,6
	ld  ix,textImageBuffer
	jp  iPutSprite

;input: A = character ID
;output: A = width, HL = chracter bitmap location, C = first byte at (HL)
getCharWidthAndLoc:
    ld  L,a
    ld  h,0
    ld  e,L
    ld  d,h
    add hl,hl
    add hl,de   ;multiply by 3 to arrive at fixed-width font offset.
    ld  de,fontData
    add hl,de
    ld  c,(hl)  ;Retrieve first byte of font data.
    ld  a,$F0 
    and c
    cp  $F0
    jr  z,getCharWidthAndLoc_islarge
    rrca
    rrca
    rrca
    rrca    ;Rotate high nibble downward. This is our width. Which is liekly 4.
    ret     ;The low nibble in C contains the first 4 pixels of the font object.
getCharWidthAndLoc_islarge:
    ld  a,$0F
    and c   ;If large font entry, width is actually in low nibble.
    ret

;NOTE: For decoding purposes, we added a vertical downshift feature to allow
; certain characters to reach below the baseline. This is done by setting
; bit 3 of the size field AFTER it is retrieved via getCharWidthAndLoc.
; Whether it is bit 3 or bit 7 of the actual first byte is not our concern.
;NOTE: If you [AND 7] to strip out vertical shift bit and the result is zero,
;      then this is to be treated as a width of 8.

;Convenience function that preserves all registers that would be
;destroyed via printChar
PutC:
	push ix \ push af \ push bc \ push de \ push hl
		call printChar
	pop hl \ pop de \ pop bc \ pop af \ pop ix
	ret

;==============================================================================
putBlankSpace:
	push af
		ld  a,(textx)
		add a,4
		ld  (textx),a
	pop af
	ret

;same input/output as below. Calling routine must properly fidangle with IX
dispIXInd:
	ld	L,(ix+0)
	ld	h,(ix+1)
	ld	c,(ix+2)
	push af
		ld b,a
		and 7
		jr	nz,$+4
		ld	a,8
		bit dhl_fetch_long_values,a
		jr	z,$+3
		inc	a  ;if longvals defined, allow upper range of decimals to be reached
		cp	2
		jr	nc,dispIXInd_2bext ;if less than 3 digits, blank out H (2nd byte)
		ld	h,$00
		bit 7,L  ;check for that bit to see if sign extension is needed.
		jr	z,dispIXInd_2bext
		bit dhl_indic_neg_sign,a
		jr	z,dispIXInd_2bext
		dec h
dispIXInd_2bext:
		cp	4
		jr	nc,dispIXInd_3bext ;if less than 5 digits, blank out C (3rd byte)
		ld	c,$00
		jr	z,dispIXInd_3bext
		bit dhl_indic_neg_sign,a
		jr	z,dispIXInd_3bext
		dec c
dispIXInd_3bext:
	pop af
	;runs into the following routine: dispHL

;in: HL=number (treated as unsigned unless appropriate flag is set)
;    A=flags  0pnrzddd :d=digits (1=1digit,5=5digit) : r=right-align number
;             76543210  n=signed number. show neg sign if needed
;                       p=signed number. show pos sign if needed
;                       z=show leading zeroes
;out: text.
;dest: AF BC DE HL
dispHL:
	ld	(iy+numflags),$00
	ld	(iy+tempfvar),a
	and	7
	jr	nz,$+4
	ld	a,8  ;if zero, set count to 8
	ld	b,a  ;B = number of digits to display
	dec a
	; Below is a compatibility layer because the numprint we have here
	; is a 24-bit variant. I'd use a 16-bit variant, but I can't be arsed
	; write or find one.
	push af  ;to sign-extend C     
		xor a
		bit dhl_indic_neg_sign,(iy+tempfvar)
		jr	z,+_
		ld	a,h
		add a,a
		ld	a,$00
		sbc a,a
_:		ld	c,a
	pop af
 	;End compatibility layer. Let's get to the meat and potatoes of it.
	bit dhl_indic_neg_sign,(iy+tempfvar)
	jr	z,dispHL_skipnegcheck
	bit 7,c
	jr	z,dispHL_skipnegcheck
	ld	a,L ; A long way to NEGate C:HL
	cpl     ;
	add a,1 ;
	ld	L,a ;
	ld	a,h ;
	cpl     ;
	adc a,0 ;
	ld	h,a ;
	ld	a,c ;
	cpl     ;
	adc a,0 ;
	ld	c,a ;
	set is_negative,(iy+numflags)
dispHL_skipnegcheck:
	;B = number of digits to display
	push hl
		ld	hl,dispHL_limits
		call dispHL_grabtableindex
	pop de
	;C:DE is where the number is now.
 	;cur-max. If no-carry at end, set cur to max
	ld	a,e
	sub (hl)
	inc hl
	ld	a,d
	sbc a,(hl)
	inc hl
	ld	a,c
	sbc a,(hl)
	jr	c,dispHL_skipresetmax
	ld	c,(hl)
	dec hl
	ld	d,(hl)
	dec hl
	ld	e,(hl)
dispHL_skipresetmax:
	ld	hl,dispHL_counts
	call dispHL_grabtableindex
dispHL_mainlooprestart:
	ld	(iy+tempfvar2),'0'-1
dispHL_mainloop:
	;Algorithm: cur-table, saveback result. 
	;Run main loop, incrementing tempfvar2 digit until result carries.
	;Then undo the final subtraction, maybe-emit digit, then restart the
	;main loop until no more digits are to be emitted.
	inc (iy+tempfvar2)
	ld	a,e
	sub (hl)
	ld	e,a
	inc hl
	ld	a,d
	sbc a,(hl)
	ld	d,a
	inc hl
	ld	a,c
	sbc a,(hl)
	ld	c,a
	dec hl
	dec hl
	jr nc,dispHL_mainloop
	ld	a,e
	add a,(hl)
	ld	e,a
	inc hl
	ld	a,d
	adc a,(hl)
	ld	d,a
	inc hl
	ld	a,c
	adc a,(hl)
	ld	c,a
	push de
		ld	de,-(2+3) ;to move pointer to start of previous item on the list
		add hl,de
	pop	de
	ld	a,(iy+tempfvar2)
	cp	'0'


	jr	nz,disphl_skip_to_displaying_number
;well. we encountered our zero. Is it a leading zero?
	bit leading_nonzero_found,(iy+numflags)
	jr	nz,disphl_skip_to_really_displaying_number
 ;okay, so it is a leading zero. Do we actually display it?
	bit dhl_show_lead_zeroes,(iy+tempfvar)
	jr	nz,disphl_skip_to_disp_signed_decide
;Okay. It's a leading zero and we're not displaying it. Check for
;right-alignedness, which really means insert a space if so.
	bit dhl_right_align_num,(iy+tempfvar)
	jr	z,disphl_skip_all_and_return_to_main_loop
	call PutBlankSpace
	jr	disphl_skip_all_and_return_to_main_loop
;this one is jumped to only on zero-check
disphl_skip_to_displaying_number:
;but first run check if a nonzero number has already been found. If so, then
;check to see if you're going to apply pos or minus sign.
	bit leading_nonzero_found,(iy+numflags)
	jr	nz,disphl_skip_initial_leading_nonzero_actions
disphl_skip_to_disp_signed_decide:
;so this is the very first leading nonzero number? Great! Check to see if
;this is a signed number. If not, then just skip forward to displaying num.
	bit dhl_indic_neg_sign,(iy+tempfvar)
	jr	z,disphl_skip_initial_leading_nonzero_actions
;We've got to display a sign or something. Right. Let's check to see if the
;number is negative. If not, skip to checking to see if we display a positive
	bit is_negative,(iy+numflags)
	jr	z,disphl_try_to_display_positive
;okay, so what we have is definitely a negative number. We're not worried
;about alignedness at this point. Either we display it or we don't. But do
;we display that? We passed through all the necessary tests, so yeah. We do.
	ld	a,'-'
	call PutC
	jr	disphl_skip_initial_leading_nonzero_actions
;Now that we're trying to display a postive number, do we actually display it?
;Now's a great time to check it. 
disphl_try_to_display_positive:
	bit dhl_show_pos_sign,(iy+tempfvar)
	jr	z,disphl_skip_displaying_positive
;So. We display the + sign since that's what's called for.
	ld	a,'+'
	call PutC
	jr	disphl_skip_initial_leading_nonzero_actions
disphl_skip_displaying_positive:
;right. so we aren't displaying a positive sign but the number is still
;signed. Do we insert spaces to do alignmentness? Check here.
	bit dhl_right_align_num,(iy+tempfvar)
	jr z,disphl_skip_initial_leading_nonzero_actions
	call putBlankSpace
disphl_skip_initial_leading_nonzero_actions:
	set leading_nonzero_found,(iy+numflags)
disphl_skip_to_really_displaying_number:
	ld	a,(iy+tempfvar2)
	call PutC
disphl_skip_all_and_return_to_main_loop:
	ld	a,b
	cp	2
	jr	nz,disphl_not_showing_last_number
;force showing the last zero if the input number is, in fact, just zero.
	set dhl_show_lead_zeroes,(iy+tempfvar)  
disphl_not_showing_last_number:
	dec b
	jp	nz,dispHL_mainlooprestart
	ret

;B=index HL=table_address
dispHL_grabtableindex:
	ld a,b
	dec a
	push hl
		ld L,a
		add a,a
		add a,L
	pop hl
	jp  addAtoHL

#define displimsplit(x) .db x&$FF,(x>>8)&$FF,(x>>16)&$FF
dispHL_limits: 	;3 bytes wide for each table entry
displimsplit(9)
displimsplit(99)
displimsplit(999)
displimsplit(9999)
displimsplit(99999)
displimsplit(999999)
displimsplit(9999999)

dispHL_counts: 	;3 bytes wide for each table entry
displimsplit(1)
displimsplit(10)
displimsplit(100)
displimsplit(1000)
displimsplit(10000)
displimsplit(100000)
displimsplit(1000000)
displimsplit(10000000)




fontInv:
	.db %00000000
	.db %10000000
	.db %11000000
	.db %11100000
	.db %11110000
	.db %11111000
	.db %11111100
	.db %11111110
	.db %11111111

;Sourced from the DoorCS software (by Kerm "Martian") and used with permission.
fontData .equ $-(' '*3)
fontData_start .equ fontData
 ; .db $00,$00,$00				;CHR_0 0 0
 ; .db $00,$00,$00				;CHR_1 0 0
 ; .db $00,$00,$00				;CHR_2 0 0
 ; .db $00,$00,$00				;CHR_3 0 0
 ; .db $00,$00,$00				;CHR_4 0 0
 ; .db $00,$00,$00				;CHR_5 0 0
 ; .db $00,$00,$00				;CHR_6 0 0
 ; .db $00,$00,$00				;CHR_7 0 0
 ; .db $00,$00,$00				;CHR_8 0 0
 ; .db $00,$00,$00				;CHR_9 0 0
 ; .db $00,$00,$00				;CHR_10 0 0
 ; .db $00,$00,$00				;CHR_11 0 0
 ; .db $00,$00,$00				;CHR_12 0 0
 ; .db $00,$00,$00				;CHR_13 0 0
 ; .db $00,$00,$00				;CHR_14 0 0
 ; .db $00,$00,$00				;CHR_15 0 0
 ; .db $00,$00,$00				;CHR_16 0 0
 ; .db $00,$00,$00				;CHR_17 0 0
 ; .db $00,$00,$00				;CHR_18 0 0
 ; .db $00,$00,$00				;CHR_19 0 0
 ; .db $00,$00,$00				;CHR_20 0 0
 ; .db $00,$00,$00				;CHR_21 0 0
 ; .db $00,$00,$00				;CHR_22 0 0
 ; .db $00,$00,$00				;CHR_23 0 0
 ; .db $00,$00,$00				;CHR_24 0 0
 ; .db $00,$00,$00				;CHR_25 0 0
 ; .db $00,$00,$00				;CHR_26 0 0
 ; .db $00,$00,$00				;CHR_27 0 0
 ; .db $00,$00,$00				;CHR_28 0 0
 ; .db $00,$00,$00				;CHR_29 0 0
 ; .db $00,$00,$00				;CHR_30 0 0
 ; .db $00,$00,$00				;CHR_31 0 0
 .db $20,$00,$00				;spacebar 0 0
 .db $42,$64,$08				;exclMark 0 0
 .db $4a,$a0,$00				;doublequote 0 0
 .db $F6 \ .dw DCSF_GS_nsg	;DCSF_GS_nsg 0 0
 .db $F6 \ .dw DCSF_GS_dsg	;DCSF_GS_dsg 0 0
 .db $4a,$24,$8a				;percentSign 0 0
 .db $54,$a4,$a5				;DCSF_GS_amp 0 0
 .db $28,$80,$00				;singlequote 0 0
 .db $34,$88,$84				;openParen 0 0
 .db $38,$44,$48				;closeParen 0 0
 .db $F6 \ .dw DCSF_GS_ast	;DCSF_GS_ast 0 0
 .db $40,$4e,$40				;plusSign 0 0
 .db $30,$04,$48				;comma 0 0
 .db $40,$0e,$00				;minusSign 0 0
 .db $20,$00,$08				;period 0 0
 .db $42,$24,$88				;forwardSlash 0 0
 .db $44,$aa,$a4				;zero 0 0
 .db $44,$c4,$4e				;one 0 0
 .db $44,$a2,$4e				;two 0 0
 .db $4c,$26,$2c				;three 0 0
 .db $42,$ae,$22				;four 0 0
 .db $4e,$86,$2e				;five 0 0
 .db $46,$8e,$ae				;six 0 0
 .db $4e,$24,$88				;seven 0 0
 .db $46,$a4,$ae				;eight 0 0
 .db $46,$ae,$2c				;nine 0 0
 .db $20,$80,$80				;colon 0 0
 .db $30,$40,$48				;semicolon 0 0
 .db $42,$48,$42				;lessthan 0 0
 .db $40,$e0,$e0				;equalto 0 0
 .db $48,$42,$48				;greaterthan 0 0
 .db $46,$a4,$04				;qmark 0 0
 .db $F6 \ .dw DCSF_GS_asg	;DCSF_GS_asg 0 0
 .db $44,$ae,$aa				;A 0 0
 .db $4c,$ae,$ae				;B 0 0
 .db $46,$88,$86				;C 0 0
 .db $4c,$aa,$ac				;D 0 0
 .db $4e,$8c,$8e				;E 0 0
 .db $4e,$8c,$88				;F 0 0
 .db $46,$8a,$a6				;G 0 0
 .db $4a,$ae,$aa				;H 0 0
 .db $4e,$44,$4e				;I 0 0
 .db $46,$22,$ac				;J 0 0
 .db $4a,$ac,$ca				;K 0 0
 .db $48,$88,$ae				;L 0 0
 .db $4a,$ee,$aa				;M 0 0
 .db $4c,$aa,$aa				;N 0 0
 .db $44,$aa,$a4				;O 0 0
 .db $4c,$aa,$c8				;P 0 0
 .db $44,$aa,$e6				;Q 0 0
 .db $4c,$ac,$aa				;R 0 0
 .db $46,$86,$2c				;S 0 0
 .db $4e,$44,$44				;T 0 0
 .db $4a,$aa,$a6				;U 0 0
 .db $4a,$aa,$a4				;V 0 0
 .db $4a,$ae,$ea				;W 0 0
 .db $4a,$c4,$6a				;X 0 0
 .db $4a,$a6,$44				;Y 0 0
 .db $4e,$24,$8e				;Z 0 0
 .db $44,$ae,$a4				;theta 0 0
 .db $48,$84,$22				;backslash 0 0
 .db $3c,$44,$4c				;closeBracket 0 0
 .db $44,$a0,$00				;tothePower 0 0
 .db $40,$00,$0e				;underscore 0 0
 .db $3c,$48,$00				;backquote 0 0
 .db $40,$c6,$ae				;a 0 0
 .db $48,$8c,$ae				;b 0 0
 .db $40,$68,$86				;c 0 0
 .db $42,$26,$ae				;d 0 0
 .db $40,$4a,$ce				;e 0 0
 .db $34,$8c,$88				;f 0 0
 .db $c6,$ae,$2c				;g 1 0
 .db $48,$8c,$aa				;h 0 0
 .db $28,$08,$88				;i 0 0
 .db $b4,$04,$48				;j 1 0
 .db $48,$ac,$ca				;k 0 0
 .db $28,$88,$88				;l 0 0
 .db $40,$ae,$aa				;DCSF_GS_m 0 0
 .db $40,$ca,$aa				;n 0 0
 .db $40,$6a,$ac				;o 0 0
 .db $cc,$ae,$88				;p 1 0
 .db $c6,$ae,$22				;q 1 0
 .db $40,$ac,$88				;r 0 0
 .db $40,$68,$6e				;s 0 0
 .db $38,$c8,$84				;t 0 0
 .db $40,$aa,$a6				;u 0 0
 .db $40,$aa,$a4				;v 0 0
 .db $40,$aa,$ea				;DCSF_GS_wl 0 0
 .db $40,$a4,$4a				;x 0 0
 .db $ca,$a6,$24				;y 1 0
 .db $40,$e2,$4e				;DCSF_GS_zl 0 0
 .db $46,$48,$46				;CHR_123 0 0
 .db $28,$88,$88				;CHR_124 0 0
 .db $4c,$42,$4c				;CHR_125 0 0
 .db $50,$5a,$00				;DCSF_GS_tilde 0 0
 .db $1e,$0e,$0e				;CHR_127 0 0
 .db $34,$e0,$00				;upArrow 0 0
 .db $30,$00,$e4				;downArrow 0 0
DCSF_GS_nsg			.db $50,$f8,$50,$f8,$50	;
DCSF_GS_dsg			.db $78,$a0,$70,$28,$f0	;
DCSF_GS_ast			.db $20,$a8,$70,$a8,$20	;
DCSF_GS_asg			.db $70,$08,$68,$a8,$70	;

fontData_end:

; Copied from somewhere but I can't recall where. Probably from the ION library.
; Graphical routine. Places 8x8 sprite object onto screen using XOR logic.
; B=height L=y A=x IX=sprPtr
iPutSprite:
	ld	e,l
	ld	h,$00
	ld	d,h
	add	hl,de
	add	hl,de
	add	hl,hl
	add	hl,hl
	ld	e,a
	and	$07
	ld	c,a
	srl	e
	srl	e
	srl	e
	add	hl,de
	ld	de,plotSScreen
	add	hl,de
imPutSpriteLoop1:
	ld	d,(ix)
	ld	e,$00
	ld	a,c
	or	a
	jr	z,imPutSpriteSkip1
imPutSpriteLoop2:
	srl	d
	rr	e
	dec	a
	jr	nz,imPutSpriteLoop2
imPutSpriteSkip1:
	ld	a,(hl)
	xor	d
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	xor	e
	ld	(hl),a
	ld	de,$0B
	add	hl,de
	inc	ix
	djnz	imPutSpriteLoop1
	ret

; Based on the routine above, but renders the 8x8 sprite via OR logic.
; B=height L=y A=x IX=sprPtr
iPutSpriteOR:
	ld	e,l
	ld	h,$00
	ld	d,h
	add	hl,de
	add	hl,de
	add	hl,hl
	add	hl,hl
	ld	e,a
	and	$07
	ld	c,a
	srl	e
	srl	e
	srl	e
	add	hl,de
	ld	de,plotSScreen
	add	hl,de
imPutSpriteLoopOR1:
	ld	d,(ix)
	ld	e,$00
	ld	a,c
	or	a
	jr	z,imPutSpriteSkipOR1
imPutSpriteLoopOR2:
	srl	d
	rr	e
	dec	a
	jr	nz,imPutSpriteLoopOR2
imPutSpriteSkipOR1:
	ld	a,(hl)
	or	d
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	or	e
	ld	(hl),a
	ld	de,$0B
	add	hl,de
	inc	ix
	djnz	imPutSpriteLoopOR1
	ret


; Based on the iPutSprite two routines above, but inverts the sprite object
; as it is being rendered. Rendering is done using XOR logic.
; B=height L=y A=x IX=sprPtr
iPutSpriteInv:
	ld	e,l
	ld	h,$00
	ld	d,h
	add	hl,de
	add	hl,de
	add	hl,hl
	add	hl,hl
	ld	e,a
	and	$07
	ld	c,a
	srl	e
	srl	e
	srl	e
	add	hl,de
	ld	de,plotSScreen
	add	hl,de
imPutSpriteInvLoop1:
	ld	a,(ix)
    cpl
    ld d,a
	ld	e,$00
	ld	a,c
	or	a
	jr	z,imPutSpriteInvSkip1
imPutSpriteInvLoop2:
    srl d
	rr	e
	dec	a
	jr	nz,imPutSpriteInvLoop2
imPutSpriteInvSkip1:
	ld	a,(hl)
	xor	d
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	xor	e
	ld	(hl),a
	ld	de,$0B
	add	hl,de
	inc	ix
	djnz	imPutSpriteInvLoop1
	ret

