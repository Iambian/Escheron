; Text rendering and tools
;
;


.varloc("tempdata")
textImageBuffer   .var(8)
.varvalidate(TEMPDATA_SIZE)


printStringF:
	ld  a,(textx)
	ld	(textxstart),a
printStringF_loop:
	ld	a,(hl)
	inc hl
	or	a
	ret z
	cp  '\n'
	jr	nz,+_
	ld  a,(textxstart)
	ld	(textx),a
	ld	a,(texty)
	add a,NEWLINE_HEIGHT
	ld	(texty),a
	jr printStringF_loop
_:  cp  '\r'
	jr  nz,+_
	ld  a,(textx)
	ld	(textxstart),a
	jr 	printStringF_loop
_:	push hl
		call printChar
	pop hl
	jr	printStringF_loop


printString:
	ld	a,(hl)
	inc hl
	or  a
	ret z
	push hl
		call printChar
	pop hl
	jr  printString


printChar:
	ld  de,textImageBuffer
    ld  L,a
    ld  h,0
    ld  c,L
    ld  b,h
    add hl,hl
    add hl,bc   ;multiply by 3 to arrive at fixed-width font offset.
    ld  bc,fontData
    add hl,bc
    ld  c,(hl)  ;Retrieve first byte of font data.
    ld  a,$F0 
    and c
    cp  $F0
	jr	z,printChar_wide
	;Size is in high nibble of C (and A). First byte of stream in low nibble.
	;Size for thin character cannot be higher than 4, so testing bit 7 for
	;vertical shift is safe. Size still needs to be preserved.
	add a,a
	jr	nc,printChar_thinVertSkip
	xor a
	ld	(de),a
	inc de
	res 7,c
printChar_thinVertSkip:
	ld	a,c
	rlca
	rlca
	rlca
	rlca
	ld  c,a
	and $F0
	ld	(de),a
	inc de
	;Preserving size before it is destroyed
	ld	a,c
	and $0F
	push af		;**
		ld  b,2
printChar_thinLoop:
		inc hl
		ld	c,(hl)
		ld  a,$F0
		and c
		ld	(de),a
		inc de
		ld  a,c
		rlca
		rlca
		rlca
		rlca
		and $F0
		ld  (de),a
		inc de
		djnz printChar_thinLoop
		jr  printChar_render
printChar_wide:
	;Size is in low nibble of C. It is technically possible for a wide char to
	;be 8 wide, but bit 3 is repurposed for vertical split. None of the
	;original characters are that wide, but just in case, treat a width of
	;zero (0) after AND 7 as a width of 8 since wide characters cannot
	;be zero-width (if they were, they'd be thin characters, not wide. A
	;deviation from this is considered a formatting error.)
	bit 3,c
	jr	nz,printChar_wideVertSkip
	res 3,c
	xor a
	ld  (de),a
	inc de
printChar_wideVertSkip:
	ld  a,c
	and 7
	jr	nz,printChar_wideDoNotFixWidth
	ld	a,8
printChar_wideDoNotFixWidth:
	push af		;**
		inc hl
		ld  a,(hl)
		inc hl
		ld  h,(hl)
		ld  L,a
		ld  bc,5
		ldir
printChar_render:
		xor a
		ld	(de),a
.assert(texty == (textx+1), "Var texty must be immediately after textx")
		ld	hl,(textx)
	pop af		;**
	add a,L
	ld  (textx),a
	ld  a,L
	ld  L,h
	ld  b,6
	ld  ix,textImageBuffer
	jr  iPutSprite



; Copied from somewhere but I can't recall where. Probably from the ION library.
; Graphical routine. Places 8x8 sprite object onto screen using XOR logic.
; B=height L=y A=x IX=sprPtr
iPutSprite:
	ld	e,l
	ld	h,$00
	ld	d,h
	add	hl,de
	add	hl,de
	add	hl,hl
	add	hl,hl
	ld	e,a
	and	$07
	ld	c,a
	srl	e
	srl	e
	srl	e
	add	hl,de
	ld	de,plotSScreen
	add	hl,de
imPutSpriteLoop1:
	ld	d,(ix)
	ld	e,$00
	ld	a,c
	or	a
	jr	z,imPutSpriteSkip1
imPutSpriteLoop2:
	srl	d
	rr	e
	dec	a
	jr	nz,imPutSpriteLoop2
imPutSpriteSkip1:
	ld	a,(hl)
	xor	d
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	xor	e
	ld	(hl),a
	ld	de,$0B
	add	hl,de
	inc	ix
	djnz	imPutSpriteLoop1
	ret

; Based on the routine above, but renders the 8x8 sprite via OR logic.
; B=height L=y A=x IX=sprPtr
iPutSpriteOR:
	ld	e,l
	ld	h,$00
	ld	d,h
	add	hl,de
	add	hl,de
	add	hl,hl
	add	hl,hl
	ld	e,a
	and	$07
	ld	c,a
	srl	e
	srl	e
	srl	e
	add	hl,de
	ld	de,plotSScreen
	add	hl,de
imPutSpriteLoopOR1:
	ld	d,(ix)
	ld	e,$00
	ld	a,c
	or	a
	jr	z,imPutSpriteSkipOR1
imPutSpriteLoopOR2:
	srl	d
	rr	e
	dec	a
	jr	nz,imPutSpriteLoopOR2
imPutSpriteSkipOR1:
	ld	a,(hl)
	or	d
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	or	e
	ld	(hl),a
	ld	de,$0B
	add	hl,de
	inc	ix
	djnz	imPutSpriteLoopOR1
	ret


; Based on the iPutSprite two routines above, but inverts the sprite object
; as it is being rendered. Rendering is done using XOR logic.
; B=height L=y A=x IX=sprPtr
iPutSpriteInv:
	ld	e,l
	ld	h,$00
	ld	d,h
	add	hl,de
	add	hl,de
	add	hl,hl
	add	hl,hl
	ld	e,a
	and	$07
	ld	c,a
	srl	e
	srl	e
	srl	e
	add	hl,de
	ld	de,plotSScreen
	add	hl,de
imPutSpriteInvLoop1:
	ld	a,(ix)
    cpl
    ld d,a
	ld	e,$00
	ld	a,c
	or	a
	jr	z,imPutSpriteInvSkip1
imPutSpriteInvLoop2:
    srl d
	rr	e
	dec	a
	jr	nz,imPutSpriteInvLoop2
imPutSpriteInvSkip1:
	ld	a,(hl)
	xor	d
	ld	(hl),a
	inc	hl
	ld	a,(hl)
	xor	e
	ld	(hl),a
	ld	de,$0B
	add	hl,de
	inc	ix
	djnz	imPutSpriteInvLoop1
	ret
















;input: A = character ID
;output: A = width, HL = chracter bitmap location, C = first byte at (HL)
getCharWidthAndLoc:
    ld  L,a
    ld  h,0
    ld  e,L
    ld  d,h
    add hl,hl
    add hl,de   ;multiply by 3 to arrive at fixed-width font offset.
    ld  de,fontData
    add hl,de
    ld  c,(hl)  ;Retrieve first byte of font data.
    ld  a,$F0 
    and c
    cp  $F0
    jr  z,getCharWidthAndLoc_islarge
    rrca
    rrca
    rrca
    rrca    ;Rotate high nibble downward. This is our width. Which is liekly 4.
    ret     ;The low nibble in C contains the first 4 pixels of the font object.
getCharWidthAndLoc_islarge:
    ld  a,$0F
    and c   ;If large font entry, width is actually in low nibble.
    ret

;NOTE: For decoding purposes, we added a vertical downshift feature to allow
; certain characters to reach below the baseline. This is done by setting
; bit 3 of the size field AFTER it is retrieved via getCharWidthAndLoc.
; Whether it is bit 3 or bit 7 of the actual first byte is not our concern.
;NOTE: If you [AND 7] to strip out vertical shift bit and the result is zero,
;      then this is to be treated as a width of 8.














fontInv:
	.db %00000000
	.db %10000000
	.db %11000000
	.db %11100000
	.db %11110000
	.db %11111000
	.db %11111100
	.db %11111110
	.db %11111111

;Sourced from the DoorCS software (by Kerm "Martian") and used with permission.
fontData .equ $-(' '*3)
fontData_start .equ fontData
 ; .db $00,$00,$00				;CHR_0 0 0
 ; .db $00,$00,$00				;CHR_1 0 0
 ; .db $00,$00,$00				;CHR_2 0 0
 ; .db $00,$00,$00				;CHR_3 0 0
 ; .db $00,$00,$00				;CHR_4 0 0
 ; .db $00,$00,$00				;CHR_5 0 0
 ; .db $00,$00,$00				;CHR_6 0 0
 ; .db $00,$00,$00				;CHR_7 0 0
 ; .db $00,$00,$00				;CHR_8 0 0
 ; .db $00,$00,$00				;CHR_9 0 0
 ; .db $00,$00,$00				;CHR_10 0 0
 ; .db $00,$00,$00				;CHR_11 0 0
 ; .db $00,$00,$00				;CHR_12 0 0
 ; .db $00,$00,$00				;CHR_13 0 0
 ; .db $00,$00,$00				;CHR_14 0 0
 ; .db $00,$00,$00				;CHR_15 0 0
 ; .db $00,$00,$00				;CHR_16 0 0
 ; .db $00,$00,$00				;CHR_17 0 0
 ; .db $00,$00,$00				;CHR_18 0 0
 ; .db $00,$00,$00				;CHR_19 0 0
 ; .db $00,$00,$00				;CHR_20 0 0
 ; .db $00,$00,$00				;CHR_21 0 0
 ; .db $00,$00,$00				;CHR_22 0 0
 ; .db $00,$00,$00				;CHR_23 0 0
 ; .db $00,$00,$00				;CHR_24 0 0
 ; .db $00,$00,$00				;CHR_25 0 0
 ; .db $00,$00,$00				;CHR_26 0 0
 ; .db $00,$00,$00				;CHR_27 0 0
 ; .db $00,$00,$00				;CHR_28 0 0
 ; .db $00,$00,$00				;CHR_29 0 0
 ; .db $00,$00,$00				;CHR_30 0 0
 ; .db $00,$00,$00				;CHR_31 0 0
 .db $20,$00,$00				;spacebar 0 0
 .db $42,$64,$08				;exclMark 0 0
 .db $4a,$a0,$00				;doublequote 0 0
 .db $F6 \ .dw DCSF_GS_nsg	;DCSF_GS_nsg 0 0
 .db $F6 \ .dw DCSF_GS_dsg	;DCSF_GS_dsg 0 0
 .db $4a,$24,$8a				;percentSign 0 0
 .db $54,$a4,$a5				;DCSF_GS_amp 0 0
 .db $28,$80,$00				;singlequote 0 0
 .db $34,$88,$84				;openParen 0 0
 .db $38,$44,$48				;closeParen 0 0
 .db $F6 \ .dw DCSF_GS_ast	;DCSF_GS_ast 0 0
 .db $40,$4e,$40				;plusSign 0 0
 .db $30,$04,$48				;comma 0 0
 .db $40,$0e,$00				;minusSign 0 0
 .db $20,$00,$08				;period 0 0
 .db $42,$24,$88				;forwardSlash 0 0
 .db $44,$aa,$a4				;zero 0 0
 .db $44,$c4,$4e				;one 0 0
 .db $44,$a2,$4e				;two 0 0
 .db $4c,$26,$2c				;three 0 0
 .db $42,$ae,$22				;four 0 0
 .db $4e,$86,$2e				;five 0 0
 .db $46,$8e,$ae				;six 0 0
 .db $4e,$24,$88				;seven 0 0
 .db $46,$a4,$ae				;eight 0 0
 .db $46,$ae,$2c				;nine 0 0
 .db $20,$80,$80				;colon 0 0
 .db $30,$40,$48				;semicolon 0 0
 .db $42,$48,$42				;lessthan 0 0
 .db $40,$e0,$e0				;equalto 0 0
 .db $48,$42,$48				;greaterthan 0 0
 .db $46,$a4,$04				;qmark 0 0
 .db $F6 \ .dw DCSF_GS_asg	;DCSF_GS_asg 0 0
 .db $44,$ae,$aa				;A 0 0
 .db $4c,$ae,$ae				;B 0 0
 .db $46,$88,$86				;C 0 0
 .db $4c,$aa,$ac				;D 0 0
 .db $4e,$8c,$8e				;E 0 0
 .db $4e,$8c,$88				;F 0 0
 .db $46,$8a,$a6				;G 0 0
 .db $4a,$ae,$aa				;H 0 0
 .db $4e,$44,$4e				;I 0 0
 .db $46,$22,$ac				;J 0 0
 .db $4a,$ac,$ca				;K 0 0
 .db $48,$88,$ae				;L 0 0
 .db $4a,$ee,$aa				;M 0 0
 .db $4c,$aa,$aa				;N 0 0
 .db $44,$aa,$a4				;O 0 0
 .db $4c,$aa,$c8				;P 0 0
 .db $44,$aa,$e6				;Q 0 0
 .db $4c,$ac,$aa				;R 0 0
 .db $46,$86,$2c				;S 0 0
 .db $4e,$44,$44				;T 0 0
 .db $4a,$aa,$a6				;U 0 0
 .db $4a,$aa,$a4				;V 0 0
 .db $4a,$ae,$ea				;W 0 0
 .db $4a,$c4,$6a				;X 0 0
 .db $4a,$a6,$44				;Y 0 0
 .db $4e,$24,$8e				;Z 0 0
 .db $44,$ae,$a4				;theta 0 0
 .db $48,$84,$22				;backslash 0 0
 .db $3c,$44,$4c				;closeBracket 0 0
 .db $44,$a0,$00				;tothePower 0 0
 .db $40,$00,$0e				;underscore 0 0
 .db $3c,$48,$00				;backquote 0 0
 .db $40,$c6,$ae				;a 0 0
 .db $48,$8c,$ae				;b 0 0
 .db $40,$68,$86				;c 0 0
 .db $42,$26,$ae				;d 0 0
 .db $40,$4a,$ce				;e 0 0
 .db $34,$8c,$88				;f 0 0
 .db $c6,$ae,$2c				;g 1 0
 .db $48,$8c,$aa				;h 0 0
 .db $28,$08,$88				;i 0 0
 .db $b4,$04,$48				;j 1 0
 .db $48,$ac,$ca				;k 0 0
 .db $28,$88,$88				;l 0 0
 .db $40,$ae,$aa				;DCSF_GS_m 0 0
 .db $40,$ca,$aa				;n 0 0
 .db $40,$6a,$ac				;o 0 0
 .db $cc,$ae,$88				;p 1 0
 .db $c6,$ae,$22				;q 1 0
 .db $40,$ac,$88				;r 0 0
 .db $40,$68,$6e				;s 0 0
 .db $38,$c8,$84				;t 0 0
 .db $40,$aa,$a6				;u 0 0
 .db $40,$aa,$a4				;v 0 0
 .db $40,$aa,$ea				;DCSF_GS_wl 0 0
 .db $40,$a4,$4a				;x 0 0
 .db $ca,$a6,$24				;y 1 0
 .db $40,$e2,$4e				;DCSF_GS_zl 0 0
 .db $46,$48,$46				;CHR_123 0 0
 .db $28,$88,$88				;CHR_124 0 0
 .db $4c,$42,$4c				;CHR_125 0 0
 .db $50,$5a,$00				;DCSF_GS_tilde 0 0
 .db $1e,$0e,$0e				;CHR_127 0 0
 .db $34,$e0,$00				;upArrow 0 0
 .db $30,$00,$e4				;downArrow 0 0
DCSF_GS_nsg			.db $50,$f8,$50,$f8,$50	;
DCSF_GS_dsg			.db $78,$a0,$70,$28,$f0	;
DCSF_GS_ast			.db $20,$a8,$70,$a8,$20	;
DCSF_GS_asg			.db $70,$08,$68,$a8,$70	;

fontData_end:



