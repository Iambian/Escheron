
;NOTE: Prior iteration is using 915 bytes for partial charstatus and main menu
;new size 1588. size with old code removed is 805. 
#define __REPARSE_INTERVAL 0

chardisp_options    .equ 5      ;2b flags
;union boundary: 7
menu_resist         .equ 7      ;1b resist value
menu_weakness       .equ 8      ;1b weakness value
menu_attack         .equ 9      ;1b attack value
menu_temp           .equ 7      ;2b temporary purposes
menu_numswap        .equ 9      ;very temporary values. For math purposes
;
menu_basefile       .equ 11     ;2b index to save file
;union boundary 13
menu_slotoffset     .equ 13     ;1b (use 2) charslot id offset (0-2)
menu_slotid         .equ 13     ;1b (use 2) ID of character slot (1-N)
menu_slotpos        .equ 13     ;2b slot address
menu_tempswap       .equ 15     ;Extended memory


;#define mx_clear m_ldaf(menu_zero, 2)

.org $4000
; -- Init base state
    m_seta(defaultSaveFile)
    m_ldfa(menu_basefile, 2)
    m_exai()

; -- DRAW SINGLE CHARACTER
    m_drawbox(0,0,96,24)        ;BG: character box
    m_seta(0)   ;charslot 2
    m_ldfa(menu_slotoffset, 2)
    m_print(menu_dc_single)
    m_drawbox(0,24,96,64)       ;FG: status details box
    m_print(menu_dc_char_details)
    m_eof

; -- SHOW MAIN MENU
    m_drawbox(0,0,96,64)    ;mainbox
    ;m_drawbox(60,45,92,63)  ;moneybox
    ;m_addxy(0,2)
    ;m_ldind2(gold_stash)
    ;m_dispacc(mf_5DIGIT|mf_RIGHT_ALIGN) \ .db "G"
    ;m_drawbox(60,0,92,46)   ;statusbox
    ;.db "Item\nMagic\nEquip\nStatus\nSave"
    m_seta(mm_LIST_MAGBOOST)
    m_ldfa(chardisp_options, 2)
    m_print(menu_dc_multi)
    m_eof


menu_dc_single:
    m_drawbox(0,0,24,24)
    m_setxy(4,4)
    m_setleft()
    m_seta(mm_LIST_SINGLE)
    m_ldfa(chardisp_options, 2)
    m_print(menu_dc_lookup_from_offset)
    m_print(menu_dc_lines_from_single)
    m_eof

;(menu_basefile) = ptr to save file start
menu_dc_multi:
    m_ldaf(menu_basefile, 2)
    m_exai()        ;place into index
    m_setxy(8,5)
    m_setleft()
    ;
    m_ldind(charslotid1)
    m_ldfa(menu_slotid, 2)
    m_print(menu_dc_lines)
    ;
    m_ldind(charslotid2)
    m_ldfa(menu_slotid, 2)
    m_print(menu_dc_lines)
    ;
    m_ldind(charslotid3)
    m_ldfa(menu_slotid, 2)
    m_print(menu_dc_lines)
    m_eof


;input: (menu_slotoffset) = slot offset, I = savefileindex
menu_dc_lookup_from_offset:
    m_ldaf(menu_slotoffset, 2)
    m_addi()
    m_exai()
    m_ldind(0)
    m_ldfa(menu_slotid, 2)
.assert((player0-playerobj) < 128, "Distance to first charslot must be int8.")
;input: (menu_slotid) = slot id.
menu_dc_lookup_from_id:
    m_seta0(player0-playerobj)
    m_sext()                    ;one slot prior
    m_addaf(menu_basefile, 2)   ;and set the adjusted address to 1 slot prior.
    m_exai()                    ;Store result into index.
    m_ldaf(menu_slotid-1, 2)    ;Get slot ID into MSB of A
    m_seta0(playerobj)          ;Slot size into LSB
    m_mltacc()                  ;Multiply to get distance into modified index
    m_addi()                    ;And complete the address to character data.
    m_ldfa(menu_slotpos, 2)     ;Copy result to memory
    m_exai()                    ;and move result in index.
    m_eof

;input: A = slotID (0-6)
menu_dc_lines:
    m_seta(1)
    m_addind(p_id)
    m_djnz(_)
    m_addxy(0, 19)      ;if slotid was zero, skip downward to next row.
    m_eof
_:  
    m_print(menu_dc_lookup_from_id)
;input: I = character slot address
menu_dc_lines_from_single:
    ; Begin portrait render
    m_ldind(p_id)
    m_exai()    ;storing charID into index for addition purposes.
    m_seta(dispCharslots_temp_portraittable)
    m_addi()
    m_exai()    ;completed address to portraitid in I
    m_ldind(0)
    m_run(menu_drawPortrait)
    ; Position text cursor to start of first line, clearing box edge if single.
    m_addxy(20, 0)
    m_ldaf(chardisp_options, 2)
    m_jrbz(mmb_single, _)
    m_addxy(4, 0)
_:  ; Begin printing character name
    m_ldaf(menu_slotpos, 2)
    m_exai()        ;restore character data address to I
    m_ldind(p_id)   ;character ID
    m_swap()        ;move character ID to a1 (MSB)
    m_seta0(8)      ;character names are fixed-width 8 wide (including 0-term)
    m_mltacc()      ;a0*a1 = offset to name
    m_exaap()       ;move to temp
    m_seta(dispCharslots_temp_chartable)
    m_addap()       ;complete address to string to display
    m_printacc()    ;print string at that address
    m_newline()
    m_addxy(20,-1)
    m_ldaf(chardisp_options, 2)
    m_jrbz(mmb_single, _)
    m_addxy(4, 0)
_:  ; Text ptr advanced to start of second line. This part is flags-adjustable.
    m_print(menu_dc_line_second)
    ;prep return registers
    m_newline()
    m_addxy(0, 4)
    m_ldaf(menu_basefile, 2)
    m_exai()
    m_eof


menu_dc_line_second:
    m_ldaf(chardisp_options, 2)
    m_jrbz(mmb_list_short, _)
    m_ldind2(p_hp)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    .db SYM_HP ," "
    m_print(menu_dc_line_msg_poison_or_sleep)
    m_eof
_:  m_jrbz(mmb_list_long, _)
    m_print(menu_dc_line_msg_state)
    m_newline()
    m_addxy(48, -(2*NEWLINE_HEIGHT)+1)
    m_print(menu_dc_line_msg_hpmhp)
    m_newline()
    m_addxy(48, -1)
    m_print(menu_dc_line_msg_mpmmp)
    m_eof
_:  m_jrbz(mmb_list_hpboost , _)
    m_ldind2(p_maxhp)
    m_dispacc(mf_4DIGIT|mf_RIGHT_ALIGN)
    .assert(MAX_ALLOWED_HP == 600, "Mismatch between defined MAX_ALLOWED_HP value and value used here.")
    .db " ", SYM_HP ," (600 max)"
    m_eof
_:  m_jrbz(mmb_list_mpboost , _)
    m_ldind(p_maxmp)
    m_dispacc(mf_4DIGIT|mf_RIGHT_ALIGN)
    .assert(MAX_ALLOWED_MP == 255, "Mismatch between defined MAX_ALLOWED_MP value and value used here.")
    .db " ",SYM_MP," (255 max)"
    m_eof
_:  m_jrbz(mmb_list_atkboost , _)
    m_ldind(p_atk)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    .db " ATK ("
    m_seta(dispCharslots_temp_maxatktable)
    m_exaap()
    m_print(menu_dc_line_msg_maxfinish)
    m_eof
_:  m_jrbz(mmb_list_defboost , _)
    m_ldind(p_def)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    .db " DEF ("
    m_seta(dispCharslots_temp_maxdeftable)
    m_exaap()
    m_print(menu_dc_line_msg_maxfinish)
    m_eof
_:  m_jrbz(mmb_list_magboost , _)
    m_ldind(p_mgc)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    .db " MAG ("
    m_seta(dispCharslots_temp_maxmagtable)
    m_exaap()
    m_print(menu_dc_line_msg_maxfinish)
    m_eof
_:  m_jrbz(mmb_list_agiboost , _)
    m_ldind(p_agi)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    .db " AGI ("
    m_seta(dispCharslots_temp_maxagitable)
    m_exaap()
    m_print(menu_dc_line_msg_maxfinish)
    m_eof
_:  m_jrbz(mmb_list_onlystatus , _)
    m_print(menu_dc_line_msg_state)
    m_eof
_:  m_jrbz(mmb_single , _)
    m_print(menu_dc_line_msg_state)
    m_newline()
    m_addxy(52, -(2*NEWLINE_HEIGHT)+1)
    m_print(menu_dc_line_msg_hpmhp)
    m_newline()
    m_addxy(52, -1)
    m_print(menu_dc_line_msg_mpmmp)
    m_eof
;Placeholder for future additions
;_:  m_jrbz( , _)
;    m_exaap2()
;    ;
;    m_eof
_:   m_eof  ;No match? No display.

; AP = table address to use
menu_dc_line_msg_maxfinish:
    m_ldind(p_id)
    m_addap()
    m_exiip()   ;save current index
    m_exai()    ;move address to max stat byte to index
    m_ldind(0)  ;Retrieve that byte
    m_dispacc(mf_3DIGIT)
    .db " max)" ;then display it.
    m_exiip()   ;Restore original index.
    m_eof

menu_dc_line_msg_hpmhp:
    m_ldind2(p_hp)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    .db "/"
    m_ldind2(p_maxhp)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    .db SYM_HP
    m_eof

menu_dc_line_msg_mpmmp:
    m_ldind(p_mp)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    .db "/"
    m_ldind(p_maxmp)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    .db SYM_MP
    m_eof

menu_dc_line_msg_state:
    m_ldind(p_status)
    m_ldfa(menu_temp, 1)
    m_seta0(ENF_POISON|ENF_SLEEP|ENF_KO)
    m_andaf(menu_temp, 1)
    m_cpjnz(0, _)
    .db "GOOD"
    m_eof
_:  m_jrbz(ELM_KO, _)
    .db "DEAD"
    m_eof
menu_dc_line_msg_poison_or_sleep:
_:  m_ldind(p_status)
    m_jrbz(STATUS_POISON, _)
    .db SYM_POISON
_:  m_jrbz(STATUS_SLEEP, _)
    .db SYM_SLEEP
_:  m_eof

; This was placed here because both tradition AND because  a relative jump
; stands no chance of jumping over this monstrosity when it is finished.
menu_dc_char_details:
    ; Preload
    m_ldaf(menu_slotpos, 2) ;This gets filled out during name render.
    m_exai()
    ; Column 1
    m_addxy(1,0)
    m_setleft()
    .db "Attack\nDefense\nMagic\nAgility\n"
    ; Column 2
    m_addxy(30, -(4*NEWLINE_HEIGHT))
    m_setleft()
    ;--- Attack stat calculation
    m_seta(EOFST_ATK)
    m_exaap()
    m_print(menu_dc_item_getstats)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    m_newline()
    ;--- Defense stat calculation
    m_seta(EOFST_DEF)
    m_exaap()
    m_print(menu_dc_item_getstats)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    m_newline()
    ;--- Magic stat calculation
    m_seta(EOFST_WIS)
    m_exaap()
    m_print(menu_dc_item_getstats)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    m_newline()
    ;--- Agility stat calculation
    m_seta(EOFST_AGI)
    m_exaap()
    m_print(menu_dc_item_getstats)
    m_dispacc(mf_3DIGIT|mf_RIGHT_ALIGN)
    m_newline()
    ; Column 3
    m_addxy(15, -(4*NEWLINE_HEIGHT))
    m_setleft()
    .db "Hit Rate\nEvasion\n"
    m_addxy(3,0)    ;subtle nudge
    .db "__Resist__\n"
    ;m_addxy(3,0)
    m_jsr(menu_dc_item_showresist)
    m_newline()
    ; Column 4
    m_addxy(30, -(4*NEWLINE_HEIGHT))
    m_setleft()
    ;--- Hit rate calculation
    m_print(menu_dc_item_gethitrate)
    m_swap()
    m_seta0(100)
    m_mltacc()
    m_clra0()
    m_swap()
    m_dispacc(mf_2DIGIT|mf_RIGHT_ALIGN)
    .db "%\n"
    ;--- Evasion calculation
    m_print(menu_dc_item_getevasion)
    m_swap()
    m_seta0(100)
    m_mltacc()
    m_clra0()
    m_swap()
    m_dispacc(mf_2DIGIT|mf_RIGHT_ALIGN)
    .db "%"
    m_eof


;masking logic. A=accumulator, R=resist, W=weakness
; R W rslt  | A=W ~ &R DONE.                     
; 0 0  0    |  0  1  0                 
; 1 0  1    |  0  1  1                  
; 0 1  0    |  1  0  0                  
; 1 1  0    |  1  0  0                  
;
;input: I = charstart
.assert((p_wpn-p_id) < 16, "Distance between p_wpn and p_id too long for short add.")
menu_dc_item_showresist:
    m_addi_sm(p_wpn-p_id)       ; Get offset from start of character data equipment
    m_jsr(menu_dc_item_element_collector)   ;Fills all masks
    m_ldaf(menu_weakness, 1)
    m_nota0()
    m_andaf(menu_resist, 1)
    m_jrbz(ELM_FIRE, _)
    .db SYM_FIRE
_:  m_jrbz(ELM_LIT, _)
    .db SYM_LIT
_:  m_jrbz(ELM_ICE, _)
    .db SYM_ICE
_:  m_jrbz(ELM_POISON, _)
    .db SYM_POISON
_:  m_jrbz(ELM_SLEEP, _)
    .db SYM_SLEEP
; We don't show any symbols for holy/KO/gravity. For all intents and purposes,
; nothing's supposed to resist them. A lot of bosses are weak to holy, though.
_:  m_eof   

















;input I = address to character inventory start (wpn/shl/arm/acc)
menu_dc_item_element_collector:
    ;init elemental storage
    m_clra0()
    m_ldfa(menu_resist, 1)
    m_ldfa(menu_weakness, 1)
    m_ldfa(menu_attack, 1)
    m_seta(4)       ;loop parameter.
_:  m_exaap()       ;protect (or on reentry, reprotect) the loop counter
    ;find address to character equipment start, saving this before looking up props.
    m_ldind(0)      ;get item ID from equipment slot
    m_inci()        ;next item slot
    m_exiip()       ;save character index index
    m_swap()
    m_seta0(EOFST_LENGTH)
    m_mltacc()
    m_exai()        ;middle term loaded
    ;first term loaded + fixed offset
    m_lda(dispCharslots_temp_geartable-EOFST_LENGTH+EOFST_F1)
    m_addi()
    m_exai()        ;I == start of equipment parameters
    m_jsr(menu_dc_item_element_collect_oneitemparam)
    m_jsr(menu_dc_item_element_collect_oneitemparam)
    m_jsr(menu_dc_item_element_collect_oneitemparam)
    m_exiip()       ;restore to character index
    m_exaap()       ;expose the loop counter
    m_djnz(-_)      ;and loop.
    m_eof

menu_dc_item_element_collect_oneitemparam:
    ;Break out to subroutine
    m_ldind(0)  ;retrieve property
    m_anda0(EQPR_H_MASK)    ;isolating code type bits
    m_cpjnz(EQPR_H_PROP, menu_dc_item_element_continue)
    m_ldind(0)  ;reretrieve property, now that we know it's magic typing
    m_jsr(_)
menu_dc_item_element_continue:
    m_inci()    
    m_eof
;--------
_:  m_anda0(EQPR_M_MASK)    ;isolating magic property type
    m_cpjnz(EQPR_M_RESI, _)
    ;resist one
    m_jsr(menu_dc_item_element_tomask)
    m_oraf(menu_resist, 1)
    m_ldfa(menu_resist, 1)
    m_eof
_:  m_cpjnz(EQPR_M_WEAK, _)
    ;weakness one
    m_jsr(menu_dc_item_element_tomask)
    m_oraf(menu_weakness, 1)
    m_ldfa(menu_weakness, 1)
    m_eof
_:  m_cpjnz(EQPR_M_ATTK, _)
    ;attack one
    m_jsr(menu_dc_item_element_tomask)
    m_oraf(menu_attack, 1)
    m_ldfa(menu_attack, 1)
    m_eof
_:  ;resist all. No more codes to check
    m_seta0($FF)
    m_ldfa(menu_resist, 1)
    m_eof


; If this is something we have to do more than a few times and we can't
; make it callable, we'll have to create a dedicated instruction for this.
; Because all we're doing here is right-shifting 1 by a0 bytes
menu_dc_item_element_tomask:
    m_ldind(0)
    m_anda0(EQPR_L_MASK)
    m_adda_sm(1)
    m_djnz(_)
    m_seta0((1<<0))
    m_eof
_:  m_djnz(_)
    m_seta0((1<<1))
    m_eof
_:  m_djnz(_)
    m_seta0((1<<2))
    m_eof
_:  m_djnz(_)
    m_seta0((1<<3))
    m_eof
_:  m_djnz(_)
    m_seta0((1<<4))
    m_eof
_:  m_djnz(_)
    m_seta0((1<<5))
    m_eof
_:  m_djnz(_)
    m_seta0((1<<6))
    m_eof
_:  m_seta0((1<<7))
    m_eof





;input: I = adr to char data, AP = equipment offset (the stat we are finding)
;NOTE: AP also corresponds to character data file. We'll be using that too.
;We kinda have to do it this way because equipment stats has interactions
;output: A= sum of all stats
menu_dc_item_getstats:
    m_clra()
    m_ldfa(menu_temp, 2)
    m_seta(p_wpn)   ;offset to weapon slot. Shield, armor, accessory following.
    m_addi()        ;set base address to start of equipment stack.
    m_exai()        ;and set this as our new index. Remember to restore later.
    m_print(menu_dc_item_singlestat)    ;fetch weapon data
    m_clra()
    m_addap()                           ;duplicate offset data
    m_cpjnz(EOFST_ATK, menu_dc_item_getstats_skip_atkcheck)
    ;Additional checking: if offhand slot is empty, give the weapon 50% bonus
    m_ldind(0)      ;index points to secondary slot.
    m_cpjnz(0,menu_dc_item_getstats_skip_atkcheck)
    m_ldaf(menu_temp, 2)
    m_swap()
    m_seta0(128)
    m_mltacc()      ;division by reciprocal.
    m_clra0()
    m_swap()        ;halved value here.
    m_addaf(menu_temp, 2)   ;add original value for +50%
    m_ldfa(menu_temp, 2)    ;and store it back
menu_dc_item_getstats_skip_atkcheck:
    ;NOTE: Do not concern ourselves with dual-wield mechanics other than that
    ;   its calculations takes place AFTER the total stats are calculated.
    m_print(menu_dc_item_singlestat)    ;fetch offhand data
    m_print(menu_dc_item_singlestat)    ;fetch armor data
    m_print(menu_dc_item_singlestat)    ;fetch accessory data
    ;restore to start of chardat, then immediately preserve it.
    m_ldaf(menu_slotpos, 2)             ;address to character
    m_exai()                            ;set I back to start of chardat
    m_exiip()
    m_jrbpnz(2, _)  ;Jump over character adding if no corresponding stat to use
    ;Now, add the calculated stats with character's base stat
    m_seta(p_atk-EOFST_ATK)             ;atk offset in char ptr wrt equip offset
    m_addaf(menu_slotpos, 2)            ;advance char pointer to begin offset
    m_addap()                           ;advance char pointer to actual offset
    m_exai()                            ;set I to that pointer
    m_ldind(0)                          ;retrieve character stat value
    m_addaf(menu_temp, 2)               ;and combine it with calculated stat
    ;Restore I to start of chardat,
_:  m_exiip()
    ;and begin clamping down the stat calculation values
    m_jrbz(15,_)        ;sign check.
    m_clra()            ;if negative, clamp to zero
_:  m_swap()
    m_cpjnz(0, _)       ;check high byte. If still not zero, jump to clamp at 255
    m_swap()
    m_eof
_:  m_clra0()
    m_swap()
    m_seta0(255)
    m_eof


;input: I=equipment slot, AP = equipment stat offset to add
;output: (menu_temp) added to, I = I+1
menu_dc_item_singlestat:
    m_ldind(0)      ;get itemID
    m_cpjnz(0, _)   ;Jump if slot has something to process
    m_inci()        ;otherwise advance to next item slot and return
    m_eof
    ;The math required. See? Algebra *is* useful for more than passing a class.
    ; stat = [itemdatastart+(slotsize*(itemid-1))+itemstat_offset]
    ; stat = [itemdatastart+(slotsize*itemid - slotsize)+itemstat_offset]
_:  ; stat = [itemdatastart-slotsize+(slotsize*itemid)+itemstat_offset]
menu_dc_item_singlestat_from_id:    ;this label isn't called directly. is jumped to.
    m_swap()
    m_seta0(EOFST_LENGTH)
    m_mltacc()      ;itemID * record_length
    m_exiip()       ;save pointer to item slot
    m_exai()        ;store middle term into I, discarding what was there before.
    m_seta(dispCharslots_temp_geartable-EOFST_LENGTH)
    m_addi()        ;sum middle term and start term
    m_addap()       ;sum final term. Address completed.
    m_exai()        ;put that address into I
    m_ldind(0)      ;get stat value from table
    m_jrbpnz(2, _)  ;jump if value 4-7 of 7 in AP. Corresponds to unsigned.
    m_sext()        ;sign-extend values from indices 0-3 as they are signed.
_:  m_addaf(menu_temp, 2)
    m_ldfa(menu_temp, 2)
    m_exiip()       ;restore item slot pointer
    m_inci()        ;next slot
    m_eof

;Same input as menu_dc_item_getstats. Hit rate is determined by two things:
; * AGI/2.5 -> (AGI*102)>>8. Use 103 instead of 102 for slight upward rounding.
; * Primary weapon bonus. Player is allowed to be unarmed. Only weapons go here.
;NOTE: A secondary weapon contributes nothing to this stat,
;      even if the primary weapon slot is empty.
;output: A= raw value. You still have to change it into a percent.
menu_dc_item_gethitrate:
    m_seta(EOFST_AGI)
    m_exaap()
    m_print(menu_dc_item_getstats)  ;menu_temp contains clamped value
    m_swap()
    m_seta0(103)
    m_mltacc()
    m_clra0()
    m_swap()
    m_ldfa(menu_temp, 2)    ;downrated AGI stat stored.
    m_ldind(p_wpn)
    m_cpjnz(0, _)
    ;The slot is empty. Return downrated AGI stat.
    m_ldaf(menu_temp, 2)
    m_eof
_:  m_print(menu_dc_item_gethitrate_helper)
    m_ldaf(menu_slotpos, 2)
    m_exai()    ;restore I to start of chardat
    m_ldaf(menu_temp, 2)    ;retrieve item hitrate + AGI bonus
    ; And clamp to max 255
    m_swap()
    m_cpjnz(0, _)
    m_swap()
    m_eof
_:  m_clra0()
    m_swap()
    m_seta0(255)
    m_eof

menu_dc_item_gethitrate_helper:
    m_seta(EOFST_HIT)   ;extract this stat
    m_exaap()
    m_ldind(p_wpn)      ;we lost A during call, so reestablish it.
    m_jr(menu_dc_item_singlestat_from_id)


;Same input as menu_dc_item_getstats. Evasion is determined by two things:
; * AGI/6 -> (AGI*43)>>8. Use 42 instead to round downward.
; * Secondary item slot. This may be empty. It may contain a weapon.
;   Since hit/evade stat overlap in item definitions, you should cancel a
;   lookup if the itemid is less than the first shield, since all weapons
;   occur before the first defensive item, and no other items at and beyond it
;   will have a value in the hit field.
;output: A= sum of all stats
menu_dc_item_getevasion:
    m_seta(EOFST_AGI)
    m_exaap()
    m_print(menu_dc_item_getstats)  ;menu_temp contains clamped value
    m_swap()
    m_seta0(43)
    m_mltacc()
    m_clra0()
    m_swap()
    m_ldfa(menu_temp, 2)    ;downrated AGI stat stored.
    m_ldind(p_shl)
    m_cpjnz(0, ++_)
    ;The slot is empty. Return downrated AGI stat.
_:  m_ldaf(menu_temp, 2)
    m_eof
_:  ; Check if the object is not a weapon (ID > WEAPON_END-1)
    m_ldfa(menu_numswap, 2)
    m_seta(WEAPON_END-1)
    m_subaf(menu_numswap, 2)
    m_jrbz(15, --_)     ;No carry until we hit shield. Jump to empty if result not neg.
    m_print(menu_dc_item_getevasion_helper)
    m_ldaf(menu_slotpos, 2)
    m_exai()    ;restore I to start of chardat
    m_ldaf(menu_temp, 2)    ;retrieve item hitrate + AGI bonus
    ; And clamp to max 255
    m_swap()
    m_cpjnz(0, _)
    m_swap()
    m_eof
_:  m_clra0()
    m_swap()
    m_seta0(255)
    m_eof

menu_dc_item_getevasion_helper:
    m_seta(EOFST_HIT)   ;extract this stat
    m_exaap()
    m_ldind(p_shl)      ;we lost A during call, so reestablish it.
    m_jr(menu_dc_item_singlestat_from_id)






dispCharslots_temp_chartable:
#macro X(idx, portraitid, gender, dispname, varname)
    .db dispname
#endmacro
#include "src/xdefs/players.z80"

dispCharslots_temp_portraittable:
#macro X(idx, portraitid, gender, dispname, varname)
    .db portraitid
#endmacro
#include "src/xdefs/players.z80"


dispCharslots_temp_maxatktable:
#macro Y(id, maxatk, maxdef, maxmag, maxagi)
    .db maxatk
#endmacro
#include "src/xdefs/players.z80"

dispCharslots_temp_maxdeftable:
#macro Y(id, maxatk, maxdef, maxmag, maxagi)
    .db maxdef
#endmacro
#include "src/xdefs/players.z80"

dispCharslots_temp_maxmagtable:
#macro Y(id, maxatk, maxdef, maxmag, maxagi)
    .db maxmag
#endmacro
#include "src/xdefs/players.z80"

dispCharslots_temp_maxagitable:
#macro Y(id, maxatk, maxdef, maxmag, maxagi)
    .db maxagi
#endmacro
#include "src/xdefs/players.z80"

; THIS LABEL WILL BE DEFINED IN THE MENU SYSTEM UPON INTEGRATION
menu_drawPortrait:
    .db $00
    .db $C9
; THIS LABEL WILL BE DEFINED IN THE MENU SYSTEM UPON INTEGRATION
menu_drawBox:
    .db $00
    .db $C9


dispCharslots_temp_geartable:
#macro X(id,nm,gc,at,de,wi,ag,hi,cr,f1,f2,f3)
    .db at,de,wi,ag,hi,cr,f1,f2,f3
#endmacro
#include "src/xdefs/items.z80"


