;#include "src/inc/osdefs.inc"
;#include "src/inc/macros.inc"
;#include "src/inc/gamedefs.inc"

;#include "src/xdefs/items.z80"
;#include "src/xdefs/spells.z80"

#define getpage(adr) ((adr&$00FF0000)>>16)+0
#define lo(adr) (adr&$FF)+0
#define hi(adr) ((adr>>8)&$FF)+0
#define xy(x,y) (256*y)+x
#define ml(m,l) (256*m)+l
#define m_eof           .db 0
#define m_setxy(x,y)    .db 1,x,y
#define m_addxy(x,y)    .db 2,x,y
#define m_drawbox(x1,y1,x2,y2) .db 3,x1,y1,x2,y2
#define m_dispacc(flags) .db 4,flags    ;numeric display A given flags.
#define m_printacc()    .db 5       ;prints at address A
#define m_call(adr)     .db 6, lo(adr), hi(adr)
#define m_clra0()       .db 7       ; 0 -> a0
#define m_seta0(v)      .db 8,v     ; v -> a0
#define m_menuopt()     .db 9       ;CTRL CODE: TAB
#define m_newline()     .db 10      ;CTRL CODE: LF
#define m_swap()        .db 11      ; a0 <-> a1
#define m_exaap()       .db 12      ; A <-> AP
#define m_setleft()     .db 13      ;CTRL CODE: CR
#define m_exiip()       .db 14      ; I <-> IP
#define m_exai()        .db 15      ; A <-> I
#define m_addap()       .db 16      ; A + AP -> A
#define m_addi()        .db 17      ; A + I -> A
#define m_sext()        .db 18      ; a0 sign-extends into a1
#define m_addind(v)     .db 19,v    ; uint8_t([ I + v ]) + A -> A
#define m_mltacc()      .db 20      ; a0 * a1 -> A
#define m_djnz(rel)     .db 21, rel-$-1 ;A--, `JR rel` if A != 0
#define m_write()       .db 22      ; a0 -> [I]
;Recipes
#define m_seta(v) m_seta0((v>>8)&$FF) \ m_swap() \ m_seta0(v&$FF)
#define m_seti(v) m_exai() \ m_seta(v) \ m_exai()
#define m_print(adr) m_seta(adr) \ m_printacc()
#define m_printsafe(adr) m_exaap() \ m_print(adr) \ m_exaap()
#define m_printidx() m_exai() \ m_printacc() \ m_exai()
#define m_mltacc1(v) m_swap() \ m_seta0(v) \ m_mltacc() \ m_swap() \ m_clra0() \ m_swap()
#define m_mltacc2(v) m_swap() \ m_seta0(v) \ m_mltacc() \ m_clra0() \ m_swap()
#define m_clra() m_clra0() \ m_swap() \ m_clra0()
#define m_clri() m_exai() \ m_clra() \ m_exai()
#define m_add(v) m_exaap() \ m_seta(v) \ m_addap()


; Parse method for jumps make it so the pointer is incremented past the end
; of the instruction BEFORE the relative address is added, therefore, an
; infinite loop with its own instruction should always evalulate to
; [negative][instruction-width]
;

m_seta($1234)

;m_setxy($05,5)    ;this is a comment
;.db "Welcome \rto Americana.\nPlease make your\nselection, followed\nby the pound\nsign now.\n"
;m_setacc2(%11110000)
;m_printacc(mf_2DIGIT|mf_RIGHT_ALIGN|mf_SIGNED_SHOW_NEG|mf_SIGNED_SHOW_POS)
;.db " Hello.",0
;.db 0
;.echo "This is a test. Address: ",saveSScreen,", here."

;Comprehensive macro function testing.
;macro(
;.directive(1, 2, other(3, 4), 5) \ biscuit("something", something)
;MyMacro("foo, bar", 2)
;MyMacro()
;macro(1, 2, (2, 3), 4)
;macro(1, 2, $44h
